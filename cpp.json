{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	
	"CP Template": {
        "prefix": "cp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "// Macros",
            "#define ALL(x) (x).begin(), (x).end()",
            "#define RALL(x) (x).rbegin(), (x).rend()",
            "#define int long long           // Comment this line if you want to use actual int",
            "#define double long double      // Comment this line if you want to use actual double",
            "",
            "// Aliases",
            "using ull = unsigned long long;",
            "using p = pair<int, int>;",
            "using v = vector<int>;",
            "using m = map<int, int>;",
            "using vv = vector<v>;",
            "using us = unordered_set<int>;",
            "",
            "// Constants",
            "constexpr int inf = LLONG_MAX;",
            "constexpr int mod = 1e9 + 7;",
            "",
            "",
            "",
            "void solve() {",
            "\t${0:// Read input",
            "\t// Example: int n; cin >> n;",
            "\t",
            "\t// Process input and solve the problem",
            "\t// Example: cout << n * n << endl;",
            "\t",
            "\t// Output result}",
            "}",
            "",
            "",
            "",
            "signed main() {",
            "\tios_base::sync_with_stdio(false);",
            "\tcin.tie(nullptr);",
            "",
            "\tint t = 1;",
            "\t",
            "\t${1:// cin >> t;}       // Uncomment this line if there are multiple test cases",
            "",
            "\twhile (t--)",
            "\t\tsolve();",
            "",
            "\treturn 0;",
            "}",
            ""
        ],
        "description": "Basic template for cp"
    },
    "Segment Tree": {
        "prefix": "seg",
        "body": [
            "class SegmentTree {",
            "private:",
            "    int n;",
            "    int identity;",
            "    v tree;",
            "",
            "public:",
            "    int merge(int a, int b) {",
            "        return a + b;",
            "    }",
            "",
            "    SegmentTree(int n, int identity) : n(n), identity(identity) {",
            "        tree.resize(4 * n, identity);",
            "    }",
            "",
            "    // Update a[queryIdx] = val",
            "    void update(int qIdx, int val) {",
            "        function<void(int, int, int)> f = [&](int tIdx, int l, int r) -> void {",
            "            if (l == r) {",
            "                tree[tIdx] = val;",
            "                return;",
            "            }",
            "",
            "            int mid = l + (r - l) / 2;",
            "",
            "            if (qIdx <= mid) {",
            "                f(2 * tIdx + 1, l, mid);",
            "            } else {",
            "                f(2 * tIdx + 2, mid + 1, r);",
            "            }",
            "",
            "            // Heap/Priority Queue idea",
            "            // leftChild = 2 * tIdx + 1, l, mid",
            "            // rightChild = 2 * tIdx + 2, mid + 1, r",
            "            tree[tIdx] = merge(tree[2 * tIdx + 1], tree[2 * tIdx + 2]);",
            "        };",
            "",
            "        f(0, 0, n - 1);",
            "    }",
            "",
            "    int query(int l, int r) {",
            "        function<int(int, int, int)> f = [&](int tIdx, int tl, int tr) -> int {",
            "            if (l > tr || r < tl) {     // No overlap",
            "                return identity;",
            "            }",
            "",
            "            if (l <= tl && tr <= r) {       // Complete overlap",
            "                return tree[tIdx];",
            "            }",
            "",
            "            int mid = (tl + tr) / 2;",
            "            return merge(f(2 * tIdx + 1, tl, mid), f(2 * tIdx + 2, mid + 1, tr));       // Partial overlap",
            "        };",
            "",
            "        return f(0, 0, n - 1);",
            "    }",
            "};"
        ],
        "description": "Segment Tree Template"
    }
}